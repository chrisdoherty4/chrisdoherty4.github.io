'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':1,'href':'/posts/preventing-unintended-shared-slice-overwrites/','title':"Preventing unintended overwrites with shared slices",'section':"Posts",'content':"Slices Go slices are small constructs backed by a traditional array. The slice construct is light weight because it contains only a pointer to it\u0026rsquo;s first element, a length and a capacity. The slice pointer can point to any element in the backing array.\nThe length denotes the number of elements currently in the slice and the capactiy denotes the maximum number of elements allowed in the slice. Generally, the capacity of a slice is the size of the underlying array. When we add a new element to a slice that\u0026rsquo;s reached it\u0026rsquo;s capacity a new backing array is created that is typically twice the size of the current capactiy.\nPassing slices around When a slice is passed as a function argument or used as a return value it maintains a reference to the same backing array because the copy of a slice contains copies of the pointer, length and capactiy. Subsequently, changing an element in a slice causes all slices pointing to the same backing array to be updated.\nfunc update(s []string) { s[0] = \u0026#34;Banana\u0026#34; } func main() { originSlice := []string{\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} update(newSlice) fmt.Println(originSlice) // \u0026#34;Tomato\u0026#34; has changed to \u0026#34;Banana\u0026#34; } Similarly, creating a new slice containing a subset of elements with the newSlice := originSlice[startIndex:endIndexExclusive] syntax and manipulating the new slice results in data in the originSlice being updated. This includes appending data to the newSlice, that has the same capacity as the originSlice.\nfunc main() { originSlice := []string{\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} newSlice := originSlice[0:2] // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;}  newSlice = append(newSlice, \u0026#34;Banana\u0026#34;) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Banana\u0026#34;}  // Origin slice inadvertently updated  fmt.Println(originSlice) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Spinach\u0026#34;} } Protecting against append overwrites We can protect against append(...) specifically by explicitly setting the newSlice capacity to the same as the length using newSlice := originSlice[startIndex:endIndexExclusive:expectedNewSliceLen] syntax. When we try appending to the newSlice that has reached it\u0026rsquo;s capacity Go creates a new backing array with increased capacity, copies the elements in newSlice to the new backing array and returns a new slice pointing to the new backing array.\nfunc main() { originSlice := []string{\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} // New slice with capacity  newSlice := originSlice[0:2:2] // Len \u0026gt; Capacity resulting in new backing array being created.  newSlice = append(newSlice, \u0026#34;Banana\u0026#34;) // Origin slice inadvertently updated  fmt.Println(newSlice) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Banana\u0026#34;}  fmt.Println(originSlice) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} } "});})();