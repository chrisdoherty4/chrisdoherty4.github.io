'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/2020/09/releasing-go-modules/','title':"Releasing Go Modules",'section':"Posts",'content':"There are 2 main methods for releasing Go modules: Copying all sources to a version directory in the root of the repository or creating a version branch. I don\u0026rsquo;t like copying my full source to a subdirectory so I\u0026rsquo;m focusing this article on creating a version branch which is a common approach for releasing software.\nPrelude: Semantic Import Versioning #  Go uses semantic versioning (semver) for dependency management. Additionally, Go has a simple rule when importing packages.\n If an old package and a new package have the same import path, the new package must be backwards compatible with the old package.\n Written from the point of view of a package maintainer.\n When I release a backwards incompatible change, I must ensure the import path is different from the previous major release.\n The change can be achieved with a v2 suffix on the import path defined in go.mod file.\nmodule github.com/chrisdoherty4/greeter/v2 This results in import paths for the v2 major release requiring the v2 suffix.\n// Version 0 or 1 import import \u0026#34;github.com/chrisdoherty4/example\u0026#34; // Version 2 import. import \u0026#34;github.com/chrisdoherty4/example/v2  Note the suffix isn\u0026rsquo;t required for v0 or v1 because many packages are not released beyond v1. For a complete answer see Russ Cox\u0026rsquo;s FAQ post.\nReleasing a Go module with branches #  When starting development we create a go.mod file with the v0/v1 module name.\nmodule github.com/chrisdoherty4/greeter The Go tooling looks for the latest semantic version tag in the repository and checks that the requested module exists.\nIf the repository is yet to be tagged, the Go tooling will pull the tip of the default branch.\nv0 #  Until we\u0026rsquo;re ready for our first release, v0, Go will pull the tip of the default branch.\n Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT be considered stable.\n - semver item 4\nGiven v0 is considered unstable, and that the Go tooling pulls the tip of the default branch, we can develop our initial code on the default branch tagging v0 minor and patch numbers as we go.\nv1 #  When we\u0026rsquo;re ready to release v1, we create a v1 major branch, prepare the branch and create a semantic version tag.\n$ git checkout -b v1 $ git tag v1.0.0 $ git push --tags origin v1 We haven\u0026rsquo;t altetered the module name with v1 as noted in the prelude.\nNow we have a branch that we can apply backwards compatible changes to, we have our default branch representing the latest copy of our code and we haven\u0026rsquo;t duplicated the source.\nv2 and beyond #  The v2 release process is essentially the same as v1 except we must change the module name in our go.mod to include a v2 suffix.\nmodule github.com/chrisdoherty4/greeter/v2 We can apply this change on the v2 branch and then tag it as v2.0.0.\n"});index.add({'id':1,'href':'/2020/09/determining-endianness-in-go/','title':"Determining Endianness in Go",'section':"Posts",'content':"In most languages you can do some variation of the same algorithm to determine endianness. The algorithm generally involves writing 0x0100 to a 16-bit integer and checking if the 0x01 or 0x00 byte was written at the first address.\nfunc Endian() string { var i int = 0x0100 ptr := unsafe.Pointer(\u0026amp;i) if 0x01 == *(*byte)(ptr) { return \u0026#34;Big Endian\u0026#34; } else if 0x00 == *(*byte)(ptr) { return \u0026#34;Little Endian\u0026#34; } else { return \u0026#34;Unknown\u0026#34; } } "});index.add({'id':2,'href':'/2020/09/integer-conversion-in-go/','title':"Integer Conversion in Go",'section':"Posts",'content':"Go\u0026rsquo;s integer type conversion behaves differently dependent on whether you\u0026rsquo;re declaring a variable and assigning a value to it or applying a type conversion to existing data.\nDeclarig a variable and assigning a value outside the representable bounds of the variable type results in an error.\n// Fails because int8s bounds are -128 to 127 var i int8 = 128 var j int16 = 128 var k int8 = j // Fails because j was declared as in8. Converting a data to a type with less bits resuts in data with the most significant bits being dropped.\nvar i int16 = 0x0100 j := int8(i) // 0x00 as the most significant bits in i are dropped. "});index.add({'id':3,'href':'/2020/09/preventing-unintended-overwrites-with-shared-slices/','title':"Preventing unintended overwrites with shared slices",'section':"Posts",'content':"Slices #  Go slices are small constructs backed by a traditional array. The slice construct is light weight because it contains only a pointer to it\u0026rsquo;s first element, a length and a capacity. The slice pointer can point to any element in the backing array.\nThe length denotes the number of elements currently in the slice and the capactiy denotes the maximum number of elements allowed in the slice. Generally, the capacity of a slice is the size of the underlying array. When we add a new element to a slice that\u0026rsquo;s reached it\u0026rsquo;s capacity a new backing array is created that is typically twice the size of the current capactiy.\nPassing slices around #  When a slice is passed as a function argument or used as a return value it maintains a reference to the same backing array because the copy of a slice contains copies of the pointer, length and capactiy. Subsequently, changing an element in a slice causes all slices pointing to the same backing array to be updated.\nfunc update(s []string) { s[0] = \u0026#34;Banana\u0026#34; } func main() { originSlice := []string{\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} update(newSlice) fmt.Println(originSlice) // \u0026#34;Tomato\u0026#34; has changed to \u0026#34;Banana\u0026#34; } Similarly, creating a new slice containing a subset of elements with the newSlice := originSlice[startIndex:endIndexExclusive] syntax and manipulating the new slice results in data in the originSlice being updated. This includes appending data to the newSlice, that has the same capacity as the originSlice.\nfunc main() { originSlice := []string{\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} newSlice := originSlice[0:2] // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;}  newSlice = append(newSlice, \u0026#34;Banana\u0026#34;) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Banana\u0026#34;}  // Origin slice inadvertently updated  fmt.Println(originSlice) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Spinach\u0026#34;} } Protecting against append overwrites #  We can protect against append(...) specifically by explicitly setting the newSlice capacity to the same as the length using newSlice := originSlice[startIndex:endIndexExclusive:expectedNewSliceLen] syntax. When we try appending to the newSlice that has reached it\u0026rsquo;s capacity Go creates a new backing array with increased capacity, copies the elements in newSlice to the new backing array and returns a new slice pointing to the new backing array.\nfunc main() { originSlice := []string{\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} // New slice with capacity  newSlice := originSlice[0:2:2] // Len \u0026gt; Capacity resulting in new backing array being created.  newSlice = append(newSlice, \u0026#34;Banana\u0026#34;) // Origin slice inadvertently updated  fmt.Println(newSlice) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Banana\u0026#34;}  fmt.Println(originSlice) // {\u0026#34;Tomato\u0026#34;, \u0026#34;Squash\u0026#34;, \u0026#34;Lettuce\u0026#34;, \u0026#34;Spinach\u0026#34;} } "});index.add({'id':4,'href':'/2020/06/unsigned-integers/','title':"Unsigned Integers",'section':"Posts",'content':" Using an unsigned instead of an int to gain one more bit to represent positive integers is almost never a good idea\n - Bjarne Stroustrup\nDefault representation #  It\u0026rsquo;s natural to think of integers in terms of signed types because they can represent negative values. In C/C++, integer literals, without any modifiers, are signed types.\nIf done incorrectly, converting between signed and unsigned integers can be dangerous. Even when done correctly, if the program is working with a value that can\u0026rsquo;t be represented within the bounds of the target signedness the program experiences an error and that error must be dealt with.\nIt\u0026rsquo;s tempting, particularly if you know you aren\u0026rsquo;t going to need to represent values \u0026lt; 0, to use unsigned. Doing so can have dire consequences.\nRule of thumb #   If all possible numbers can be represented in the signed type, use signed\n Consider unsigned for algorithms that perform bit manipulation or with embedded systems.\n"});index.add({'id':5,'href':'/2020/05/runtime.numcpu/','title':"runtime.NumCPU",'section':"Posts",'content':"A number of books and articles I\u0026rsquo;ve read recently claim that runtime.NumCPU() returns the physical processor count. This isn\u0026rsquo;t accurate: runtime.NumCPU() has always returned the logical processor count. Perhaps the authors use the terms physical and logical interchangably given most/all mainstream processors have simaltaneous multithreading technology?\npackage main import ( \u0026#34;runtime\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(runtime.NumCPU()) } "});})();